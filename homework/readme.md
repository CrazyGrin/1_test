##工厂模式
工厂类就是一个专门用来创建其它对象的类，工厂模式通常用来返回类似接口的不同的类，工厂的一种常见用法就是创建多态的提供者。通常工厂模式有一个关键的构造，即一般被命名为factory的静态方法。这个静态方法可以接受任意数量的参数，并且必须返回一个对象。
理解：就是利用工厂类生产需要的对象，并且便于维护
应用场合：客户程序不需要知道要使用对象的创建过程；
		客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。


##单例模式
作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统全局地提供这个实例。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。
理解：为避免不必要地重复加载一个类（上一次加载器就应用了单例模式）,并且保证实例化的类是唯一的并且是可全局访问的。
应用场景：PHP单例模式我觉得针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是很有意义的。


##观察者
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
理解：一个对象通过添加一个方法（该方法允许另一个对象，即观察者 注册自己）使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者使用该信息执行的操作与可观察的对象无关。结果是对象可以相互对话，而不必了解原因。(不是很懂)
应用场景：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。
		当对一个对象的改变需要同时改变其它对象，而不知道具体有多少个对象待改变。
		当一个对象必须通知其它对象，而它又不能假定其它对象是谁。


##迭代器
迭代器（iterator）有时又称游标（cursor）是程序设计的软件设计模式，可在容器（container，例如链表或阵列）上遍访的接口，设计人员无需关心容器的内容。利用PHP的迭代器可以利用面向对象实现常见的数据结构，例如列表，堆栈，队列与图。
理解：就是用来遍历一个对象内部数据并且获得想要的结构。
应用场景：使用返回迭代器的包或库时;
		无法在一次的调用获取容器的所有元素时;
		要处理数量巨大的无素时

#RABC
RBAC是Role-Based Access Control的首字母，即基于角色的权限访问控制，也就是用户通过角色与权限进行关联[其架构灵感来源于操作系统的GBAC（GROUP-Based Access Control）的权限管理控制]。简单的来说，一个用户可以拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。